#!/usr/bin/env zsh
# rat-zsh (rz) - minimal zsh plugin manager
# deps: zsh, git

set -euo pipefail
setopt EXTENDED_GLOB
autoload -Uz is-at-least

# path
typeset -g RAT_ZSH_HOME="${RAT_ZSH_HOME:-${ZDOTDIR:-$HOME}/.rz}"
typeset -g RZ_BIN="$RAT_ZSH_HOME/bin"
typeset -g RZ_PLUGINS="$RAT_ZSH_HOME/plugins"
typeset -g RZ_REPOS="$RAT_ZSH_HOME/repos"
typeset -g RZ_CONFIG="$RAT_ZSH_HOME/config.toml"

mkdir -p "$RZ_BIN" "$RZ_PLUGINS" "$RZ_REPOS"

# colors
RZ_COLOR_RESET=$'\033[0m'
RZ_COLOR_RED=$'\033[31m'
RZ_COLOR_GREEN=$'\033[32m'
RZ_COLOR_YELLOW=$'\033[33m'
RZ_COLOR_BLUE=$'\033[34m'

# utils
_rz_slug() { print -r -- "${1//\//__}"; }

_rz_info() {
  print -r -- "${RZ_COLOR_GREEN}rz: [info]${RZ_COLOR_RESET} $*"
}

_rz_warn() {
  print -u2 -- "${RZ_COLOR_YELLOW}rz: [warn]${RZ_COLOR_RESET} $*"
}

_rz_die() {
  print -u2 -- "${RZ_COLOR_RED}rz: [error]${RZ_COLOR_RESET} $*"
  exit 1
}

_rz_log_step() {
  local st="$1" msg="${2:-}"
  case "$st" in
    start)
      printf "${RZ_COLOR_GREEN}rz: [info]${RZ_COLOR_RESET} %s ... " "$msg"
      ;;
    ok)
      printf "${RZ_COLOR_GREEN}[ok]${RZ_COLOR_RESET}\n"
      ;;
    error)
      printf "${RZ_COLOR_RED}[error]${RZ_COLOR_RESET}\n"
      ;;
  esac
}

_rz_repo_url() {
  local source="$1" repo="$2"
  case "$source" in
    github) print -r -- "https://github.com/$repo.git" ;;
    *)      print -r -- "$repo" ;; # future: gitlab etc.
  esac
}

# toml parser
# expected format
# [[plugins]]
# key = "value"
# key = "value"
_rz_parse_plugins() {
  awk '
    BEGIN {
      inblk = 0
      source=""; repo=""; rev=""; file=""; type=""; name=""
    }

    function flush() {
      if (inblk) {
        printf("%s\x1f%s\x1f%s\x1f%s\x1f%s\x1f%s\n", source, repo, rev, file, type, name)
      }
      source=""; repo=""; rev=""; file=""; type=""; name=""
      inblk = 1
    }

    function ltrim(s){ sub(/^[[:space:]]+/, "", s); return s }
    function rtrim(s){ sub(/[[:space:]]+$/, "", s); return s }
    function trim(s){ return rtrim(ltrim(s)) }

    /^[ \x1f]*#/ { next }
    /^[ \x1f]*$/ { next }

    {
      line = $0
      line = trim(line)
    }

    (index(line, "[[plugins]]") == 1) {
      flush()
      next
    }

    inblk && index(line, "=") > 0 {
      pos = index(line, "=")
      key = substr(line, 1, pos-1)
      val = substr(line, pos+1)

      key = trim(key)
      val = trim(val)

      if (substr(val,1,1) == "\"" && substr(val, length(val),1) == "\"") {
        val = substr(val, 2, length(val)-2)
      }

      if (key == "source")      source = val
      else if (key == "repo")   repo   = val
      else if (key == "rev")    rev    = val
      else if (key == "file")   file   = val
      else if (key == "type")   type   = val
      else if (key == "name")   name   = val

      next
    }

    END {
      if (inblk) {
        printf("%s\x1f%s\x1f%s\x1f%s\x1f%s\x1f%s\n", source, repo, rev, file, type, name)
      }
    }
  ' "$RZ_CONFIG"
}

# sync one
_rz_sync_one() {
  local source="$1" repo="$2" rev="$3" file="$4" type="$5" name="$6"

  [[ -z "$repo" ]] && return 0

  local slug url repo_dir plug_name plug_disp
  slug="$(_rz_slug "$repo")"
  url="$(_rz_repo_url "$source" "$repo")"
  repo_dir="$RZ_REPOS/$slug"
  plug_name="${name:-$slug}"
  plug_disp="${name:-$repo}"
  _rz_log_step start "syncing $plug_disp"

  if [[ -d "$repo_dir/.git" ]]; then
    if ! git -C "$repo_dir" fetch --depth=1 origin >/dev/null 2>&1; then
      _rz_log_step error
      return 1
    fi
    git -C "$repo_dir" submodule update --init --recursive >/dev/null 2>&1
  else
    if ! git clone --depth=1 --recurse-submodules "$url" "$repo_dir" >/dev/null 2>&1; then
      _rz_log_step error
      return 1
    fi
  fi

  if [[ -n "$rev" ]]; then
    git -C "$repo_dir" fetch --tags --depth=1 origin "$rev" >/dev/null 2>&1 || true
    git -C "$repo_dir" checkout -q "$rev" 2>/dev/null || git -C "$repo_dir" checkout -q "tags/$rev" 2>/dev/null || true
  else
    # best-effort: try default branch
    git -C "$repo_dir" reset -q --hard HEAD
  fi

  # symlink into plugins
  local link="$RZ_PLUGINS/$plug_name"
  rm -f "$link"

  if [[ "$type" == "fpath" ]]; then
    ln -s "$repo_dir" "$link"
  else
    # source type
    local srcfile
    if [[ -n "$file" && -f "$repo_dir/$file" ]]; then
      srcfile="$repo_dir/$file"
    else
      # fallback: guess a plugin file
      local f
      for f in "$repo_dir"/*(.N); do
        [[ "$f" == *.plugin.zsh || "$f" == *.zsh || "$f" == *.zsh-theme ]] && { srcfile="$f"; break; }
      done
    fi
    [[ -z "$srcfile" ]] && _rz_die "no source file found in $repo_dir"
    ln -s "$srcfile" "$link"
  fi

  _rz_log_step ok
}

# commands
rz_init() {
  cat <<'EOS'
# rat-zsh init
if [[ -z "${_RZ_INIT:-}" ]]; then
  typeset -g _RZ_INIT=1
  typeset -g RAT_ZSH_HOME="${RAT_ZSH_HOME:-$HOME/.rz}"
  typeset -g RZ_BIN="$RAT_ZSH_HOME/bin"
  typeset -g RZ_PLUGINS="$RAT_ZSH_HOME/plugins"

  export PATH="$RZ_BIN:$PATH"

  # fpath for completion-only plugins
  fpath=("$RZ_PLUGINS" $fpath)

  # compinit once
  autoload -Uz compinit
  if [[ -z "${_RZ_COMPINIT_DONE:-}" ]]; then
    typeset -g _RZ_COMPINIT_DONE=1
    compinit -u
  fi

  # Load plugins: standard ones first, then "tail" plugins that must be last.
  # We detect plugins by their repo slug taken from the symlink target under $RZ_REPOS.
  typeset -a _rz_tail_slugs=(
    zsh-users__zsh-syntax-highlighting
    zsh-users__zsh-autosuggestions
  )

  typeset -a _rz_normal _rz_tail
  # Include both symlinks (@) and plain files (-); ignore missing matches (N).
  for p in "$RZ_PLUGINS"/*(N@-); do
    # Resolve to absolute path and extract repo slug ".../repos/<slug>/..."
    target="${p:A}"
    slug=""
    if [[ $target == */repos/* ]]; then
      slug="${${target##*/repos/}%%/*}"
    fi

    # If it’s one of the tail slugs, queue it for the end; otherwise normal.
    typeset -i is_tail=0
    for s in $_rz_tail_slugs; do
      if [[ $slug == $s ]]; then
        is_tail=1; break
      fi
    done

    if (( is_tail )); then
      _rz_tail+=("$p")
    else
      _rz_normal+=("$p")
    fi
  done

  # Source normal plugins first, then tail plugins.
  for p in $_rz_normal $_rz_tail; do
    # If it’s a symlink to a file, just source it.
    if [[ -L "$p" && -f "$p" ]]; then
      source "$p"
      continue
    fi
    # Otherwise, source well-known plugin file types.
    case "$p" in
      *.zsh|*.plugin.zsh|*.zsh-theme) source "$p" ;;
    esac
  done
fi
EOS
}

rz_sync() {
  [[ -f "$RZ_CONFIG" ]] || _rz_die "config not found: $RZ_CONFIG"

  local lines
  lines="$(_rz_parse_plugins)"

  if [[ -z "$lines" ]]; then
    _rz_info "no plugins in $RZ_CONFIG"
    for p in "$RZ_PLUGINS"/*(N); do
      _rz_info "removing stale plugin: ${p:t}"
      rm -f "$p"
    done
    for r in "$RZ_REPOS"/*(N); do
      _rz_info "removing stale repo: ${r:t}"
      rm -rf "$r"
    done
    return 0
  fi

  local IFS=$'\x1f'
  local source repo rev file type name
  typeset -A _expected_name _expected_slug
  while IFS=$'\x1f' read -r source repo rev file type name; do
    local slug="$(_rz_slug "$repo")"
    local plug_name="${name:-$slug}"
    _expected_name[$plug_name]=1
    _expected_slug[$slug]=1
    _rz_sync_one "$source" "$repo" "$rev" "$file" "$type" "$name"
  done <<< "$lines"

  for p in "$RZ_PLUGINS"/*(N); do
    local base="${p:t}"
    if [[ -z "${_expected_name[$base]:-}" ]]; then
      _rz_log_step start "removing stale plugin: $base"
      if rm -f "$p"; then
        _rz_log_step ok
      else
        _rz_log_step error
      fi
    fi
  done

  typeset -A _in_use_slug

  for p in "$RZ_PLUGINS"/*(N@); do
    local target="${p:A}" slug=""
    if [[ $target == */repos/* ]]; then
      slug="${${target##*/repos/}%%/*}"
      (( ${#slug} )) && _in_use_slug[$slug]=1
    fi
  done

  for r in "$RZ_REPOS"/*(N/); do
    local slug="${r:t}"
    if [[ -z "${_expected_slug[$slug]:-}" && -z "${_in_use_slug[$slug]:-}" ]]; then
      _rz_log_step start "removing stale repo: $slug"
      if rm -rf "$r"; then
        _rz_log_step ok
      else
        _rz_log_step error
      fi
    fi
  done

  _rz_info "sync done"
}

rz_list() {
  [[ -f "$RZ_CONFIG" ]] || _rz_die "config not found: $RZ_CONFIG"
  local US=$'\x1f'
  _rz_parse_plugins | awk -v FS="$US" '{
    t = ($5=="" ? "source" : $5)
    display = ($6 != "" ? $6 : $2)
    printf "- %s (%s) [%s]\n", display, $1, t
  }'
}

rz_home() { print -r -- "$RAT_ZSH_HOME"; }

# Show the order plugins would be sourced in (normal first, then tail plugins).
rz_order() {
  # Slugs that must be sourced last (by repo slug under $RZ_REPOS).
  typeset -a _rz_tail_slugs=(
    zsh-users__zsh-syntax-highlighting
    zsh-users__zsh-autosuggestions
  )

  # Build a set for O(1) tail check.
  typeset -A _rz_tail_set
  local t
  for t in $_rz_tail_slugs; do _rz_tail_set[$t]=1; done

  typeset -a normal tail
  local p target slug
  # Include symlinks (@) and plain files (-); ignore misses (N).
  for p in "$RZ_PLUGINS"/*(N@-); do
    target="${p:A}"   # resolve to absolute
    slug=""
    # Extract repo slug if the target lives under .../repos/<slug>/...
    [[ $target == */repos/* ]] && slug="${${target##*/repos/}%%/*}"

    if [[ -n ${_rz_tail_set[$slug]-} ]]; then
      tail+=("$p")
    else
      normal+=("$p")
    fi
  done

  local q disp
  for q in $normal $tail; do
    disp="${q:t}"              # link basename (this is "name" or slug)
    # If it's a slug (owner__repo), display owner/repo for readability.
    [[ $disp == *"__"* ]] && disp="${disp//__//}"
    print -r -- "- $disp"
  done
}

# dispatch
case "${1:-}" in
  init)  rz_init ;;
  sync)  rz_sync ;;
  list)  rz_list ;;
  home)  rz_home ;;
  order) rz_order ;;
  ""|help|-h|--help)
    cat <<EOF
rat-zsh (rz) - minimal zsh plugin manager
RAT_ZSH_HOME=${RAT_ZSH_HOME}

Usage:
  rz init     # print init code (add to .zshrc: eval "\$("\$(rz home)/bin/rz" init)")
  rz sync     # fetch/update plugins defined in \$RAT_ZSH_HOME/config.toml
  rz list     # list parsed plugins
  rz home     # show RAT_ZSH_HOME
  rz order    # show the effective load order
EOF
    ;;
  *)
    _rz_die "unknown command: $1"
    ;;
esac
